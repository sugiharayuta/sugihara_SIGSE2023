\section{考察\label{discussion}}

% \subsection{レコードの検出数について}

% 本節では，以下の目的のもと，クラスに関して取得した統計について記載する．

% \begin{quote}
%   \begin{itemize}
%     \item レコードの検出数である3,244件という数値が，OSSの規模と比較してどの程度の大きさなのか把握する．
%     \item レコードへのリファクタリングに適格であるクラスを検出することで，本研究の結果とそれに基づいた知見が今後どの程度変化しそうか把握する．
%   \end{itemize}
% \end{quote}

% クラスの検出は，以下の条件別に行った．

% \begin{itemize}
%   \item[（1） ] レコードに必須な前提条件を満たしている．（クラスの修飾子にabstract，sealed，non-sealedのいずれも含まれておらず，継承元のクラスが無い上に，インスタンスイニシャライザも定義されていない．）
%   \item[（2） ] （1）に加え，クラスがfinalでないインスタンスフィールドをもたない．
%   \item[（3） ] （2）に加え，クラスが1つ以上のfinalなインスタンスフィールドをもつ．
%   \item[（4） ] （3）に加え，レコードに変換することで，削減可能な要素が含まれている．（クラスが，カノニカルコンストラクタ，toString/hashCode/equalsメソッド，ゲッタメソッドのいずれかをもつ．）
%   \item[（5） ] （4）に加え，クラスがfinalであり，明示的に継承禁止である．
% \end{itemize}

% ここでいうカノニカルコンストラクタは，引数の型の組み合わせがfinalなインスタンスフィールドと等しいものとしている．
% なお，可変長引数の型は配列型として扱っている．

% \begin{table}[t]
%   \caption{条件別のクラス総数（レコードの使用履歴があったリポジトリ）}
%   \label{class_immutability_71}
%   \centering
%   \begin{tabular}{c||r|r}
%       \hline
%       条件 & 削減件数 & 割合\\
%       \hline\hline
%       クラス総数 & 376,672 & -\\
%       （1）前提条件を満たすクラス & 182,608 & 48.5\%\\
%       （2）finalでないフィールドをもたないクラス & 129,537 & 34.4\%\\
%       （3）finalなフィールドをもつクラス & 25,814 & 6.9\%\\
%       （4）削減可能な要素をもつクラス & 17,685 & 4.7\%\\
%       （5）明示的に継承禁止のクラス & 3,779 & 1.0\%\\
%       \hline
%   \end{tabular}
% \end{table}

% \begin{table}[t]
%   \caption{条件別のクラス総数（レコードの使用履歴がなかったリポジトリ）}
%   \label{class_immutability_1929}
%   \centering
%   \begin{tabular}{c||r|r}
%       \hline
%       条件 & 削減件数 & 割合\\
%       \hline\hline
%       クラス総数 & 1,278,418 & -\\
%       （1）前提条件を満たすクラス & 540,517 & 42.3\%\\
%       （2）finalでないフィールドをもたないクラス & 321,313 & 25.1\%\\
%       （3）finalなフィールドをもつクラス & 93,959 & 7.3\%\\
%       （4）削減可能な要素をもつクラス & 62,775 & 4.9\%\\
%       （5）明示的に継承禁止のクラス & 13,002 & 1.0\%\\
%       \hline
%   \end{tabular}
% \end{table}

% \tabref{class_immutability_71}は，\ref{rq1_method}節の調査でレコードの使用履歴があった71リポジトリにおける結果である．
% また，\tabref{class_immutability_1929}はそれ以外の1,929のリポジトリにおける結果である．
% これらの結果から，レコードの検出数である3,244件という値は，レコードの検出があったリポジトリのクラス総数のおよそ116分の1，データセット全体のクラス総数のおよそ510分の1で，決して多くはないといえる．
% また，レコードの検出があったリポジトリにおいても，そうでないリポジトリにおいてもレコードへのリファクタリングが適格であるクラスが5\%弱存在しており，今後レコードへの置換が進められる可能性がある．
% すなわち，本研究の結果やそれに基づく知見は，リファクタリングが進行するにつれて今後変化する可能性がある．

\subsection{各RQの考察}
\subsubsection{RQ1}
RQ1では，OSSのコミット履歴を遡り，レコードの適用数の変化について調査した．
その結果，Java17のリリース以降でレコードの適用数の増加が2.66倍に加速していることがわかった．
レコードが正式に登場したJava16リリース時点ではなく，Java17のリリース以降で適用数の増加が加速したのは，Java17が長期サポートであることが理由であると考えられる．
関連研究\cite{Generics_Research}でも，OSSにおける言語仕様の導入時期にはJavaのバージョンが大きく関与すると述べられており，レコードもOSSにJava17が導入されることを契機にして利用が進んだものと考えられる．

\subsubsection{RQ2}
RQ2の前半では，レコードのインスタンスフィールドについて調査した．
その結果，レコードの方がクラスよりもフィールドの個数が平均1個程度多いということがわかった．
さらに，フィールド型の全体における割合で見た場合，レコードの方がクラスよりもStringの利用が目立っていることがわかった．
これらの結果から，レコードの用途として多いのは，文字列データの保持であるということがわかる．

なお，本来レコードは値の保持を目的とする型であるが，\tabref{num_fields}によると要素数0のレコードも全体の9.8\%見受けられる．
これらのレコードを目視で調査したところ，ほとんどはリポジトリcheckstyleなどにおける，ソースコードのスタイル例としての利用であった．
ただ，リポジトリsignal-cliなどの一部のOSSでは，要素数0のレコードをソフトウェア部品として利用していると思われるケースも存在した．
これらはfinal classの代替であると思われるが，レコード宣言の制約を利用し，今後のフィールド追加などの編集を制限する目的も含まれていると考えられる．

RQ2の後半では，レコードに実装されるインタフェースについて調査し，レコードの方がクラスよりもSerializableが実装されている割合が高く，一方でRunnableが実装されている割合が低いことがわかった．
このことから，実装インタフェースの側面で見ても，レコードは振る舞いよりデータの保持が重視される型宣言であるということが見てとれる．

\subsubsection{RQ3}
RQ3の前半では，コミットによって追加されたレコードが型宣言の変更によるものなのか，そうでないのかを分類した．
その結果，レコードの追加のうち22.2\%が既存の型宣言の変更によるものだということがわかった．
対して，型宣言の変更以外で既存ファイルにレコードが追加されるケースは10.7\%であり，これらも何かしらのリファクタリングである可能性はあるが，それを踏まえてもレコードを用いたリファクタリングとして趨勢を占めるのは型宣言の変更であると考えられる．

RQ3の後半では，クラスからレコードへのリファクタリングによって，クラス内部の要素がどれだけ削減されるのかを調査した．
その結果，72.3\%のリファクタリングでコンストラクタの削減が行われており，その他ゲッタメソッドやtoString/equals/hashCodeメソッドについても一定の削減がみられた．
よってレコードに暗黙的に実装される各メソッドはOSSにおいて有効に活用されており，特にカノニカルコンストラクタの実装が大きな効果を発揮しているといえる．
また，これらのリファクタリングを自動的に支援するツールによっても，開発者は同様の恩恵を得られるものであると考えられる．

\subsubsection{RQ4}

RQ4の前半では，クラスをレコードに変更するコミットの特徴を目視によって調査した．
その結果，型のフィールドあるいはゲッタメソッドの参照まわりの変更が多くみられた．
特に，レコードに暗黙的に実装されるゲッタメソッドの名前が接頭辞getを含まないという点は，リファクタリング作業に伴うコストを増幅させる原因となっていると考えられる．
今後リファクタリングのサポートを行うツールを制作する際には，このようなコストを低減できる設計が望ましいと思われる．

\begin{figure}[t]
\begin{lstlisting}
public class TextFieldEvent {
    private final TextField field;
    private final String oldval;
    private final String newval;
    
    public TextFieldEvent(TextField field, String old, String val) {
        this.field = field;
        this.oldval = old;
        this.newval = val;
    }
    
    public String getOldText() {
        return oldval;
    }
    
    public String getText() {
        return newval;
    }
    
    public TextField getTextField() {
        return field;
    }
}
\end{lstlisting}
\begin{lstlisting}
public record TextFieldEvent(
    TextField getTextField,
    String getOldText,
    String getText
){ }
\end{lstlisting}
\caption{logism-evolutionでみられたリファクタリング（上：変更前，下：変更後）}
\label{unique_usage}
\end{figure}
なお，リポジトリlogism-evolutionにおけるリファクタリングは，ゲッダメソッドの呼び出し箇所を変更するのを避けるため，レコードへの変更でヘッダに定義する変数に接頭辞getを加えていた．（\figref{unique_usage}）．
この手法は，手動でのリファクタリングに伴うコスト低減のヒントになると考えられる．

RQ4の後半では，レコード宣言がクラス宣言に差し戻された31件のケースを目視で調査し，理由を分類した．
その結果，6件が外部ツールに関わる理由であった．
レコードは実装されてから日が浅い言語仕様であるため，レコードを用いる際にはアノテーションを用いる外部ツールなどの互換性に注意を払う必要があると考えられる．
また，クラスに差し戻された理由のひとつとして，hashCodeメソッドのパフォーマンス向上を図るためというものがあった．
レコードに標準で実装されるequals/hashCodeメソッドは，再帰的に各フィールドの当該メソッドを呼び出す実装であるため，オブジェクトの入れ子構造が深くなるにつれパフォーマンスが低下する恐れがある．
よってこれらのメソッドの暗黙的な実装を目的としてレコードを導入する際には，パフォーマンス面での問題を留意しておく必要があると考えられる．

\subsection{妥当性の脅威\label{threats}}
\subsubsection{型の同定について}
\ref{field_type_trend}節，\ref{interface_trend}節などでは，型の情報を取得する調査を行っている．
本研究での型の情報は，参照ではなく文字列ベースで取得しているため，同じ型にラベル付けされていても等しい型とは限らない．
実際，\tabref{implemented_interfaces}のActionListerは，java.awt.eventパッケージのものとユーザ定義のものが取得されている．

\subsubsection{目視調査について}
本研究での目視調査は，第一著者のみによるものである．
今後は妥当性の保証のため，複数人での目視調査が望まれる．